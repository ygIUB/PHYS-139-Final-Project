#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
tile_pairs.py
Input:
  - a pairs list file, each line: <image_path>\t<mask_path>
    
Output:
  - tiled image pngs to out_img_dir
  - tiled mask  pngs to out_msk_dir
  - a summary json

Usage (inside the container):
  python /workspace/tile_pairs.py \
      --pairs /workspace/qa/pairs.txt \
      --out-img /workspace/deform/train \
      --out-msk /workspace/deform/label \
      --tile 512 --stride 512 --keep-bg false

Note:
  - Mask is binarized as (mask > 0).
  - Image is percentile (1,99) normalized to uint8.
  - Non-multiple sizes are reflect-padded to the next grid.
"""

from __future__ import annotations
import argparse
import json
import os
from math import ceil
from pathlib import Path
from typing import Tuple, List

import numpy as np
from skimage import io

try:
    from tqdm import tqdm
except Exception:
    tqdm = lambda x, **k: x  # fallback: no progress bar


def to_uint8_percentile(im: np.ndarray, p1: float = 1.0, p99: float = 99.0) -> np.ndarray:
    #Normalize image by (p1, p99) percentiles -> uint8
    imf = im.astype(np.float32)
    lo, hi = np.percentile(imf, [p1, p99])
    if hi > lo:
        imf = np.clip((imf - lo) / (hi - lo), 0, 1)
    else:
        # fallback to min-max
        lo, hi = imf.min(), imf.max()
        if hi > lo:
            imf = (imf - lo) / (hi - lo)
        else:
            imf = np.zeros_like(imf, dtype=np.float32)
    return (imf * 255.0 + 0.5).astype(np.uint8)


def reflect_pad_to_grid(im: np.ndarray, tile: int) -> np.ndarray:
    #Pad with reflect to the next multiple of tile
    H, W = im.shape[:2]
    Hn = int(ceil(H / tile) * tile)
    Wn = int(ceil(W / tile) * tile)
    if Hn == H and Wn == W:
        return im
    pad_h = Hn - H
    pad_w = Wn - W
    if im.ndim == 2:
        return np.pad(im, ((0, pad_h), (0, pad_w)), mode="reflect")
    else:  # (H, W, C)
        return np.pad(im, ((0, pad_h), (0, pad_w), (0, 0)), mode="reflect")


def iter_tiles(im: np.ndarray, mk: np.ndarray, tile: int, stride: int, keep_bg: bool):
    H, W = im.shape[:2]
    for y in range(0, H - tile + 1, stride):
        for x in range(0, W - tile + 1, stride):
            imt = im[y : y + tile, x : x + tile]
            mkt = mk[y : y + tile, x : x + tile]
            if not keep_bg and mkt.max() == 0:
                continue
            yield x, y, imt, mkt


def load_pair(ip: Path, mp: Path) -> Tuple[np.ndarray, np.ndarray] | None:
    #Read image & mask; squeeze singleton channel; validate shape
    try:
        im = io.imread(str(ip))
        mk = io.imread(str(mp))
        # squeeze trailing singleton channel if present
        if im.ndim == 3 and im.shape[-1] == 1:
            im = im[..., 0]
        if mk.ndim == 3 and mk.shape[-1] == 1:
            mk = mk[..., 0]
        if im.shape != mk.shape:
            return None
        return im, mk
    except Exception:
        return None


def main():
    parser = argparse.ArgumentParser(description="Cut paired images/masks into MoDL tiles.")
    parser.add_argument("--pairs", type=str, required=True,
                        help="pairs.txt generated by scan_pairs.py")
    parser.add_argument("--out-img", type=str, default="/workspace/deform/train",
                        help="output dir for image tiles")
    parser.add_argument("--out-msk", type=str, default="/workspace/deform/label",
                        help="output dir for mask tiles")
    parser.add_argument("--tile", type=int, default=512, help="tile size")
    parser.add_argument("--stride", type=int, default=512, help="stride")
    parser.add_argument("--keep-bg", type=str, default="false",
                        help="keep background-only tiles? (true/false)")
    parser.add_argument("--limit", type=int, default=0,
                        help="optional: only process first N pairs (for quick test)")
    parser.add_argument("--summary", type=str, default="/workspace/qa/tiling_report.json",
                        help="where to write summary json")
    args = parser.parse_args()

    keep_bg = str(args.keep_bg).lower() in {"1", "true", "yes", "y"}

    pairs_file = Path(args.pairs).resolve()
    out_img = Path(args.out_img).resolve()
    out_msk = Path(args.out_msk).resolve()
    out_img.mkdir(parents=True, exist_ok=True)
    out_msk.mkdir(parents=True, exist_ok=True)

    if not pairs_file.exists():
        raise FileNotFoundError(f"Pairs file not found: {pairs_file}")

    # read lines
    lines = [ln.strip() for ln in pairs_file.read_text(encoding="utf-8").splitlines() if ln.strip()]
    if args.limit and args.limit > 0:
        lines = lines[: args.limit]

    total_pairs = len(lines)
    n_tiles = 0
    n_drop = 0
    n_readerr = 0
    n_mismatch = 0

    for ln in tqdm(lines, desc="tiling"):
        if "\t" not in ln:
            continue
        ip_str, mp_str = ln.split("\t", 1)
        ip, mp = Path(ip_str), Path(mp_str)

        pair = load_pair(ip, mp)
        if pair is None:
            # try to distinguish mismatch vs readerr (best-effort)
            try:
                _im = io.imread(str(ip))
                _mk = io.imread(str(mp))
                if _im.ndim == 3 and _im.shape[-1] == 1:
                    _im = _im[..., 0]
                if _mk.ndim == 3 and _mk.shape[-1] == 1:
                    _mk = _mk[..., 0]
                if _im.shape != _mk.shape:
                    n_mismatch += 1
                else:
                    n_readerr += 1
            except Exception:
                n_readerr += 1
            continue

        im, mk = pair
        # normalize & binarize
        im8 = to_uint8_percentile(im)
        mkb = (mk > 0).astype(np.uint8) * 255

        # pad to grid
        im8 = reflect_pad_to_grid(im8, args.tile)
        mkb = reflect_pad_to_grid(mkb, args.tile)

        base = ip.stem  # file stem as base name
        for x, y, imt, mkt in iter_tiles(im8, mkb, args.tile, args.stride, keep_bg):
            name = f"em11037_{base}_x{x}_y{y}.png"
            io.imsave(str(out_img / name), imt, check_contrast=False)
            io.imsave(str(out_msk / name), mkt, check_contrast=False)
            n_tiles += 1

    summary = {
        "pairs_file": str(pairs_file),
        "total_pairs_read": total_pairs,
        "processed_pairs": total_pairs - (n_readerr + n_mismatch),
        "read_errors": n_readerr,
        "shape_mismatch": n_mismatch,
        "tiles_written": n_tiles,
        "out_img": str(out_img),
        "out_msk": str(out_msk),
        "tile": args.tile,
        "stride": args.stride,
        "keep_bg": keep_bg,
    }
    Path(args.summary).parent.mkdir(parents=True, exist_ok=True)
    with open(args.summary, "w", encoding="utf-8") as f:
        json.dump(summary, f, indent=2)
    print(json.dumps(summary, indent=2))


if __name__ == "__main__":
    main()
